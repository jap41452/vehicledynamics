<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vehicle Dynamics Simulator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #ddd; }
        #ui { position: absolute; top: 0; left: 0; width: 300px; height: 100vh; background: rgba(255,255,255,0.9); overflow-y: auto; padding: 10px; border-right: 1px solid #999; box-sizing: border-box; }
        #viewer { position: absolute; top: 0; left: 300px; width: calc(100vw - 300px); height: 100vh; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px; }
        label { font-size: 11px; display: block; }
        input { width: 100%; box-sizing: border-box; }
        h3 { margin: 10px 0 5px 0; font-size: 12px; border-bottom: 1px solid #ccc; }
        button { width: 100%; padding: 8px; cursor: pointer; background: #eee; border: 1px solid #ccc; }
        button:hover { background: #ddd; }
        .feat-row { font-size: 10px; border-bottom: 1px solid #eee; padding: 2px; display: flex; justify-content: space-between; }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="ui">
    <h3>Chassis</h3>
    <div class="grid">
        <label>Weight (lb)<input id="mass" type="number" value="2500"></label>
        <label>Gravity (in/s²)<input id="g" type="number" value="386.1"></label>
    </div>

    <h3>Suspension</h3>
    <div class="grid">
        <label>Front K (lb/in)<input id="k_f" type="number" value="150"></label>
        <label>Front C (lb·s/in)<input id="c_f" type="number" value="15"></label>
        <label>Rear K (lb/in)<input id="k_r" type="number" value="180"></label>
        <label>Rear C (lb·s/in)<input id="c_r" type="number" value="18"></label>
        <label>Rest Length (in)<input id="rest_len" type="number" value="20"></label>
    </div>

    <h3>Tires</h3>
    <div class="grid">
        <label>Stiffness K<input id="k_t" type="number" value="1200"></label>
        <label>Wheel Dia (in)<input id="w_d" type="number" value="32"></label>
        <label>Wheel Wt (lb)<input id="w_mass" type="number" value="100"></label>
    </div>

    <h3>Speed</h3>
    <div class="grid">
        <label>Velocity (in/s)<input id="vel" type="number" value="200"></label>
    </div>

    <button onclick="resetSim()">Reset Simulation</button>
    
    <h3>Road Features</h3>
    <button onclick="addBump()">Add Bump</button>
    <div id="featureList"></div>
</div>

<div id="viewer"></div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// --- CONFIG ---
let scene, camera, renderer, controls;
let vehicleGroup, groundGroup;
const roadFeatures = [];
let simTime = 0;

// Physics State [z, phi, theta, dz, dphi, dtheta, ...wheels(z, dz)]
// We track 4 wheels: FL, FR, RL, RR
const state = {
    z: 40, phi: 0, theta: 0, 
    dz: 0, dphi: 0, dtheta: 0,
    zw: [30, 30, 30, 30], // Wheel Z positions
    dzw: [0, 0, 0, 0]     // Wheel Z velocities
};

// Wheel Geometry Offsets (Hardcoded for simplicity based on your box sizes)
// FL, FR, RL, RR
const W_OFF = [
    {x: -36, y: 60}, {x: 36, y: 60},
    {x: -36, y: -60}, {x: 36, y: -60}
];

// --- INIT ---
function init() {
    const container = document.getElementById('viewer');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xd0d0d0);
    scene.fog = new THREE.Fog(0xd0d0d0, 500, 3000);

    camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 1, 5000);
    camera.position.set(300, -500, 300);
    THREE.Object3D.DEFAULT_UP.set(0,0,1); // Z is UP
    
    renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);
    
    controls = new OrbitControls(camera, renderer.domElement);

    // Lights
    const amb = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(100, -200, 500);
    dir.castShadow = true;
    scene.add(dir);

    // Geometry Groups
    groundGroup = new THREE.Group();
    scene.add(groundGroup);
    vehicleGroup = new THREE.Group();
    scene.add(vehicleGroup);

    // Floor
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(5000, 5000), new THREE.MeshStandardMaterial({color: 0xbbbbbb}));
    floor.receiveShadow = true;
    groundGroup.add(floor);
    
    // Grid
    const grid = new THREE.GridHelper(5000, 50);
    grid.rotation.x = Math.PI/2;
    groundGroup.add(grid);

    // Build Car
    buildCar();

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });

    animate();
}

function buildCar() {
    vehicleGroup.clear();
    
    // Chassis Body (Blue Box)
    const chassis = new THREE.Mesh(
        new THREE.BoxGeometry(72, 120, 24),
        new THREE.MeshStandardMaterial({color: 0x4477aa})
    );
    chassis.position.z = 12 + 16; // Half Height + Radius
    chassis.castShadow = true;
    vehicleGroup.add(chassis);

    // Wheels (Black Cylinders)
    const wGeo = new THREE.CylinderGeometry(16, 16, 10, 24);
    wGeo.rotateZ(Math.PI/2);
    const wMat = new THREE.MeshStandardMaterial({color: 0x222222});

    W_OFF.forEach((off, i) => {
        const w = new THREE.Mesh(wGeo, wMat);
        w.name = `W${i}`;
        // Initial visual pos
        w.position.set(off.x, off.y, 16);
        w.castShadow = true;
        vehicleGroup.add(w);
    });
}

// --- UTILS ---
function val(id) { return parseFloat(document.getElementById(id).value); }

window.resetSim = function() {
    state.z = 50; state.phi=0; state.theta=0; state.dz=0; state.dphi=0; state.dtheta=0;
    state.zw = [30,30,30,30]; state.dzw = [0,0,0,0];
    simTime = 0;
};

// --- ROAD LOGIC ---
window.addBump = function() {
    const y = 200 + (roadFeatures.length * 200); // Space them out
    const mesh = new THREE.Mesh(
        new THREE.CylinderGeometry(20, 20, 200, 32, 1, false, 0, Math.PI),
        new THREE.MeshStandardMaterial({color: 0x666666})
    );
    // Orient cylinder to be a bump on ground
    mesh.rotateZ(Math.PI/2); 
    mesh.position.set(0, y, -5); // Buried slightly
    groundGroup.add(mesh);
    
    roadFeatures.push({y: y, h: 15, w: 40});
    
    const div = document.createElement('div');
    div.className = 'feat-row';
    div.innerHTML = `Bump @ ${y}in <button onclick="this.parentElement.remove()">x</button>`;
    document.getElementById('featureList').appendChild(div);
};

function getRoadZ(x, y) {
    let z = 0;
    roadFeatures.forEach(f => {
        const dy = y - f.y;
        if (Math.abs(dy) < f.w) {
            // Simple cosine bump profile
            const h = f.h * 0.5 * (1 + Math.cos(Math.PI * dy / f.w));
            z = Math.max(z, h);
        }
    });
    return z;
}

// --- PHYSICS (RK4) ---
function getDerivs(t, s) {
    const z = s[0], phi = s[1], theta = s[2];
    const dz = s[3], dphi = s[4], dtheta = s[5];
    
    // Inputs
    const M = val('mass') / val('g');
    const Ixx = M * (72*72 + 24*24)/12; // Approx Inertia
    const Iyy = M * (120*120 + 24*24)/12;
    const g = val('g');
    const wm = val('w_mass') / g;
    const v = val('vel');
    const R = val('w_d')/2;
    const restLen = val('rest_len');

    let Fz_body = 0, Tx = 0, Ty = 0;
    const ddzw = [0,0,0,0];

    // For each wheel
    for(let i=0; i<4; i++) {
        const zw = s[6+i];
        const dzw = s[10+i];
        const off = W_OFF[i];

        // 1. Suspension Force
        // Body Height at wheel location
        const zb = z - phi*off.x + theta*off.y;
        const dzb = dz - dphi*off.x + dtheta*off.y;
        
        // Spring Compression = (RestLength) - (CurrentLength)
        // CurrentLength = zb - zw;
        const comp = restLen - (zb - zw);
        const dcomp = -(dzb - dzw);
        
        const isFront = (i < 2);
        const k = isFront ? val('k_f') : val('k_r');
        const c = isFront ? val('c_f') : val('c_r');

        // Force pushing Body UP, Wheel DOWN
        const Fs = Math.max(0, k*comp + c*dcomp);
        
        // Accumulate Body Forces
        Fz_body += Fs;
        Tx += Fs * off.y; // Pitch
        Ty -= Fs * off.x; // Roll

        // 2. Tire Force
        const roadY = off.y + (v * t);
        const roadZ = getRoadZ(off.x, roadY);
        
        // Penetration
        const pen = roadZ - (zw - R);
        const kt = val('k_t');
        const Ft = (pen > 0) ? kt * pen : 0;

        // Wheel Acceleration (Sum F = ma)
        // Forces: Ft (up), Fs (down), Gravity (down)
        ddzw[i] = (Ft - Fs - wm*g) / wm;
    }

    const ddz = (Fz_body - M*g) / M;
    const ddphi = Ty / Iyy;
    const ddtheta = Tx / Ixx;

    // Return derivatives vector
    return [
        dz, dphi, dtheta, 
        ddz, ddphi, ddtheta,
        s[10], s[11], s[12], s[13], // dzw (velocities)
        ddzw[0], ddzw[1], ddzw[2], ddzw[3] // ddzw (accels)
    ];
}

function stepPhysics(dt) {
    // Pack
    const s = [
        state.z, state.phi, state.theta,
        state.dz, state.dphi, state.dtheta,
        ...state.zw, ...state.dzw
    ];

    // RK4
    const k1 = getDerivs(simTime, s);
    const s2 = s.map((v,i) => v + k1[i]*dt*0.5);
    const k2 = getDerivs(simTime + dt*0.5, s2);
    const s3 = s.map((v,i) => v + k2[i]*dt*0.5);
    const k3 = getDerivs(simTime + dt*0.5, s3);
    const s4 = s.map((v,i) => v + k3[i]*dt);
    const k4 = getDerivs(simTime + dt, s4);

    const sf = s.map((v,i) => v + (dt/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));

    // Unpack
    state.z=sf[0]; state.phi=sf[1]; state.theta=sf[2];
    state.dz=sf[3]; state.dphi=sf[4]; state.dtheta=sf[5];
    for(let i=0; i<4; i++) {
        state.zw[i] = sf[6+i];
        state.dzw[i] = sf[10+i];
    }
    
    simTime += dt;
}

// --- ANIMATION ---
const dt = 1/120;

function animate() {
    requestAnimationFrame(animate);

    // 1. Step Physics
    stepPhysics(dt);

    // 2. Sync Visuals
    // Move Chassis
    vehicleGroup.position.set(0, 0, state.z);
    vehicleGroup.rotation.set(state.theta, state.phi, 0);

    // Move Ground (Fake speed)
    const dist = val('vel') * simTime;
    groundGroup.position.y = -dist;

    // Move Wheels (Relative)
    const R = val('w_d')/2;
    for(let i=0; i<4; i++) {
        const w = vehicleGroup.getObjectByName(`W${i}`);
        if(w) {
            // Logic: vehicleGroup is at state.z.
            // Wheel actual Z is state.zw[i].
            // Local Z = ActualZ - BodyZ.
            // + R offset because cylinder origin is center.
            w.position.z = (state.zw[i] - state.z) + R;
        }
    }

    renderer.render(scene, camera);
}

// Start
init();
</script>
</body>
</html>





















