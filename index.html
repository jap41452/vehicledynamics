<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vehicle Dynamics Module</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute; top: 10px; left: 10px; color: white; 
            font-family: monospace; background: rgba(0,0,0,0.5); padding: 10px;
        }
    </style>
</head>
<body>
    <div id="info">
        <b>Vehicle Dynamics Module</b><br>
        WASD to Drive<br>
        Space to Brake
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // --- CONFIGURATION: SUSPENSION DYNAMICS ---
        // This is where you tune the "response" of the vehicle
        const vehicleConfig = {
            mass: 150, // kg
            suspensionStiffness: 30,
            suspensionRestLength: 0.3,
            frictionSlip: 1.4,
            dampingRelaxation: 2.3,
            dampingCompression: 4.4,
            maxSuspensionForce: 100000,
            rollInfluence: 0.01, // Lower prevents rollover at high speed
            radius: 0.25 // Wheel radius
        };

        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- 2. PHYSICS WORLD ---
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.SAPBroadphase(world);

        // Physics Materials
        const groundMaterial = new CANNON.Material('ground');
        const wheelMaterial = new CANNON.Material('wheel');
        const wheelGroundContact = new CANNON.ContactMaterial(wheelMaterial, groundMaterial, {
            friction: 0.3,
            restitution: 0,
            contactEquationStiffness: 1000
        });
        world.addContactMaterial(wheelGroundContact);

        // Ground Plane
        const groundBody = new CANNON.Body({
            mass: 0, // 0 makes it static
            material: groundMaterial
        });
        groundBody.addShape(new CANNON.Plane());
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);

        // Visual Ground
        const gridHelper = new THREE.GridHelper(100, 100);
        scene.add(gridHelper);

        // --- 3. VEHICLE SETUP ---
        // Chassis Body
        const chassisShape = new CANNON.Box(new CANNON.Vec3(1, 0.25, 2)); // Half extents
        const chassisBody = new CANNON.Body({ mass: vehicleConfig.mass });
        chassisBody.addShape(chassisShape);
        chassisBody.position.set(0, 2, 0);
        chassisBody.angularDamping = 0.5;
        
        // Visual Chassis
        const chassisMesh = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.5, 4),
            new THREE.MeshStandardMaterial({ color: 0x0077ff })
        );
        chassisMesh.castShadow = true;
        scene.add(chassisMesh);

        // RaycastVehicle Controller
        const vehicle = new CANNON.RaycastVehicle({
            chassisBody: chassisBody,
        });

        const wheelOptions = {
            radius: vehicleConfig.radius,
            directionLocal: new CANNON.Vec3(0, -1, 0),
            suspensionStiffness: vehicleConfig.suspensionStiffness,
            suspensionRestLength: vehicleConfig.suspensionRestLength,
            frictionSlip: vehicleConfig.frictionSlip,
            dampingRelaxation: vehicleConfig.dampingRelaxation,
            dampingCompression: vehicleConfig.dampingCompression,
            maxSuspensionForce: vehicleConfig.maxSuspensionForce,
            isFrontWheel: true,
            useCustomSlidingRotationalSpeed: true,
            customSlidingRotationalSpeed: -30,
            axleLocal: new CANNON.Vec3(-1, 0, 0)
        };

        // Add Wheels (Front Left, Front Right, Back Left, Back Right)
        // Note: x is left/right, y is up/down, z is forward/back
        vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(0.8, 0, 1.2) });
        vehicle.addWheel({ ...wheelOptions, chassisConnectionPointLocal: new CANNON.Vec3(-0.8, 0, 1.2) });
        vehicle.addWheel({ ...wheelOptions, isFrontWheel: false, chassisConnectionPointLocal: new CANNON.Vec3(0.8, 0, -1.2) });
        vehicle.addWheel({ ...wheelOptions, isFrontWheel: false, chassisConnectionPointLocal: new CANNON.Vec3(-0.8, 0, -1.2) });

        vehicle.addToWorld(world);

        // Visual Wheels
        const wheelMeshes = [];
        vehicle.wheelInfos.forEach((wheel) => {
            const cylinderGeo = new THREE.CylinderGeometry(wheel.radius, wheel.radius, 0.3, 20);
            cylinderGeo.rotateZ(Math.PI / 2); // Rotate to correct axis
            const mesh = new THREE.Mesh(cylinderGeo, new THREE.MeshStandardMaterial({ color: 0x333333 }));
            scene.add(mesh);
            wheelMeshes.push(mesh);
        });

        // --- 4. INPUT HANDLING ---
        const keys = { w: false, a: false, s: false, d: false, space: false };
        document.addEventListener('keydown', (e) => {
            if(e.key === ' ') keys.space = true;
            if(e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = true;
        });
        document.addEventListener('keyup', (e) => {
            if(e.key === ' ') keys.space = false;
            if(e.key.toLowerCase() in keys) keys[e.key.toLowerCase()] = false;
        });

        // --- 5. ANIMATION LOOP ---
        const timeStep = 1 / 60;
        
        function animate() {
            requestAnimationFrame(animate);

            // Update Physics Inputs
            const maxSteerVal = 0.5;
            const maxForce = 500;
            const brakeForce = 20;

            // Steering
            vehicle.setSteeringValue(keys.a ? maxSteerVal : (keys.d ? -maxSteerVal : 0), 0);
            vehicle.setSteeringValue(keys.a ? maxSteerVal : (keys.d ? -maxSteerVal : 0), 1);

            // Engine
            const engineForce = keys.w ? -maxForce : (keys.s ? maxForce : 0);
            vehicle.applyEngineForce(engineForce, 2);
            vehicle.applyEngineForce(engineForce, 3);

            // Brakes
            const currentBrake = keys.space ? brakeForce : 0;
            vehicle.setBrake(currentBrake, 0);
            vehicle.setBrake(currentBrake, 1);
            vehicle.setBrake(currentBrake, 2);
            vehicle.setBrake(currentBrake, 3);

            // Step Physics
            world.step(timeStep);

            // Sync Visuals to Physics
            // Chassis
            chassisMesh.position.copy(chassisBody.position);
            chassisMesh.quaternion.copy(chassisBody.quaternion);

            // Wheels
            for (let i = 0; i < vehicle.wheelInfos.length; i++) {
                vehicle.updateWheelTransform(i);
                const transform = vehicle.wheelInfos[i].worldTransform;
                wheelMeshes[i].position.copy(transform.position);
                wheelMeshes[i].quaternion.copy(transform.quaternion);
            }

            // Camera Follow
            camera.position.x = chassisMesh.position.x + 5;
            camera.position.z = chassisMesh.position.z + 5;
            camera.lookAt(chassisMesh.position);

            renderer.render(scene, camera);
        }

        animate();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>




















